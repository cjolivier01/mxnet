/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
#include <iostream>
#include <fstream>
#include <algorithm>
#include <cstring>
#include <sstream>
#include <list>

/*!
 * \brief Some string utility functions
 *        These are meant to be functional and simple rather than performant
 */
struct StringUtil {
  /*!
   * \brief Terim whitespace from beninning and end of string
   * \param s String to trimp
   * \return reference to the modified string. This is the same std::string object as what was
   *         supplied in the parameters
   */
  static std::string &trim(std::string *s) {
    s->erase(s->begin(), std::find_if(s->begin(), s->end(), [](int ch) {
      return !std::isspace(ch);
    }));
    s->erase(std::find_if(s->rbegin(), s->rend(), [](int ch) {
      return !std::isspace(ch);
    }).base(), s->end());
    return *s;
  }
  /*!
   * \brief Tokenize a string into a list of tokens
   * \param s String to tokenize
   * \return std::list of tokens
   */
  static std::list<std::string> string2list(const std::string &s) {
    std::list<std::string> res;
    std::istringstream iss(s);
    std::string token;
    while (std::getline(iss, token, ',')) {
      trim(&token);
      if (!token.empty()) {
        res.push_back(token);
      }
    }
    return std::move(res);
  }
  /*!
   * \brief Replace all occurances, in a string, of a substring with another substring
   * \param str String to modify
   * \param from Substring to replace
   * \param to New substring to appear in modified string
   */
  static std::string& replaceAll(std::string& str, const std::string& from, const std::string& to) {
    if(!from.empty()) {
      size_t start_pos = 0;
      while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
      }
    }
    return str;
  }
};

#define REPLACE_TOKEN_PRE   "%ITEM_"
#define REPLACE_TOKEN_POST  "%"

static std::string load_template_file(const std::string& file_name) {
  std::ifstream tmpl;
  tmpl.open(file_name);
  if(tmpl.fail()) {
    std::cerr << "Error opening file: \"" << file_name << "\": " << strerror(errno) << std::endl;
    return "";
  }
  std::stringstream tmpl_buff;
  while(!tmpl.eof()) {
    std::string line;
    tmpl >> line;
    tmpl_buff << line;
  }
  tmpl.close();
  std::string tmpl_string = tmpl_buff.str();
  StringUtil::trim(&tmpl_string);
  return std::move(tmpl_string);
}

int main(int argc, char **argv) {
  int rc = 0;
  if(argc != 4) {
    std::cerr << "Usage:" << std::endl
              << argv[0]
              << " <input file> <output file> [template file]" << std::endl;
  }
  std::ifstream input, tmpl;
  input.open(argv[1]);
  if(input.fail()) {
    std::cerr << "Error opening file: \"" << argv[1] << "\": " << strerror(errno) << std::endl;
    return errno;
  }

  std::ofstream output;
  output.open(argv[2], std::ios_base::trunc|std::ios_base::out);
  if(output.fail()) {
    std::cerr << "Error opening file: \"" << argv[3] << "\": " << strerror(errno) << std::endl;
    return errno;
  }

  std::string tmpl_string;
  if(argc > 2) {
    tmpl_string = load_template_file(argv[3]);
    if (tmpl_string.empty()) {
      return errno ? errno : -1;
    }
  }

  output << "/* This file is automatically generated. DO NOT EDIT! */" << std::endl << std::endl;

  while(!input.eof()) {
    std::string token_line;
    input >> token_line;
    StringUtil::trim(&token_line);
    if(!token_line.empty() && token_line[0] != '#') {

      // Look for new template directive
      if(token_line[0] == '>') {
        std::string new_template_file = &token_line[1];
        StringUtil::trim(&new_template_file);
        tmpl_string = load_template_file(new_template_file);
        continue;
      }
      if(tmpl_string.empty()) {
        std::cerr << "No valid template" << std::endl;
        rc = -1;
        break;
      }

      std::list<std::string> tokens = StringUtil::string2list(token_line);
      std::string replaced = tmpl_string;
      size_t item = 0;
      for (auto iter = tokens.begin(), e_iter = tokens.end(); iter != e_iter; ++iter, ++item) {
        std::string token = *iter;
        StringUtil::trim(&token);
        std::string to_replace = REPLACE_TOKEN_PRE;
        to_replace += std::to_string(item);
        to_replace += REPLACE_TOKEN_POST;
        StringUtil::replaceAll(replaced, to_replace, token);
      }
      output << replaced << std::endl;
      if (output.fail()) {
        std::cerr << "Error writing file: \"" << argv[3] << "\": " << strerror(errno) << std::endl;
        return errno;
      }
    }
  }
  output.close();
  input.close();

  return rc;
}

